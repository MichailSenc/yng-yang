{"version":3,"sources":["webpack://yng-yang/./src/components/calc-yin-yang-points.js","webpack://yng-yang/./src/components/canvas.js","webpack://yng-yang/./src/components/empty-points.js","webpack://yng-yang/./src/components/points-generation.js","webpack://yng-yang/webpack/bootstrap","webpack://yng-yang/webpack/runtime/define property getters","webpack://yng-yang/webpack/runtime/hasOwnProperty shorthand","webpack://yng-yang/webpack/runtime/make namespace object","webpack://yng-yang/./src/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C,2BAA2B,sBAAsB;AACjD;AACA,qBAAqB,2BAA2B;;AAEhD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;ACpG3B;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;;AAEA,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA,eAAe,qBAAqB;AACpC;AACA,wCAAwC,SAAS;AACjD;AACA;;AAEA,mBAAmB,OAAO;AAC1B,eAAe,qBAAqB;AACpC;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;AC5G1B;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;ACxBc;;AAEzC;AACA;AACA;AACA,SAAS,0BAA0B;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kDAAW;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,0CAA0C,OAAO;AACjD;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA,0CAA0C,OAAO;AACjD;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,iBAAiB,OAAO;AACxB,gDAAgD,cAAc,MAAM,aAAa;AACjF,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,iEAAe,gBAAgB,EAAC;;;;;;;UClGhC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;ACNA;AAC8D;AACjB;AACe;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA,2BAA2B,uDAAU;;AAErC;;AAEA,IAAI,sEAAgB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,qEAAW;AAC9B;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA,CAAC","file":"main.js","sourcesContent":["class IngYangGame {\r\n    constructor(startPanel) {\r\n        this.startPanel = startPanel;\r\n        this.newPanel = startPanel.defaultMatrix();\r\n        this.worldHeight = startPanel.panel.length;\r\n    }\r\n\r\n    // выполнить переход\r\n    nextStep() {\r\n        this.startPanel.clearCanvas();\r\n        this.nextGeneration();\r\n        for (let i = 0; i < this.startPanel.panel.length; i++) {\r\n            const element = this.startPanel.panel[i];\r\n            for (let j = 0; j < element.length; j++) {\r\n                const item = element[j];\r\n                if (item) {\r\n                    this.startPanel.settings.cellType = item;\r\n                    this.startPanel.putCoordinateToCanvas(i, j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // следующие поколение клеток\r\n    nextGeneration() {\r\n        let point;\r\n        for (let i = 0; i < this.worldHeight; i++) {\r\n            for (let j = 0; j < this.worldHeight; j++) {\r\n                point = this.startPanel.panel[i][j];\r\n                let { countYng, conutYang, sum } = this.countLiveNeighbors(i, j);\r\n\r\n                if (!point) {\r\n                    if (sum == 3) {\r\n                        this.newPanel[i][j] = countYng == 1 ? \"yng\" : \"yang\";\r\n                    }\r\n                } else {\r\n                    if (sum > 4 || sum < 2) {\r\n                        this.newPanel[i][j] = null;\r\n                        continue;\r\n                    }\r\n                    if (point == \"yng\" && conutYang == 4) {\r\n                        this.newPanel[i][j] = null;\r\n                        continue;\r\n                    }\r\n                    if (point == \"yang\" && countYng == 4) {\r\n                        this.newPanel[i][j] = null;\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.startPanel.panel = this.newPanel;\r\n        this.newPanel = this.startPanel.defaultMatrix();\r\n    }\r\n\r\n    //  координаты соседей точки - окрестность мура 1 порядка\r\n    pointNeighbors(x, y) {\r\n        const neighbors = [];\r\n        for (let i = x - 1; i <= x + 1; i++) {\r\n            for (let j = y - 1; j <= y + 1; j++) {\r\n                if (i == x && j == y) continue;\r\n                neighbors.push([i, j]);\r\n            }\r\n        }\r\n        return neighbors;\r\n    }\r\n\r\n    // количество живых соседей у клетки (x,y)\r\n    countLiveNeighbors(x, y) {\r\n        let countYng = 0,\r\n            conutYang = 0,\r\n            sum = 0,\r\n            neighbors = this.pointNeighbors(x, y);\r\n\r\n        for (const item of neighbors) {\r\n            let [_x, _y] = item;\r\n            if (_x < 0 || _y < 0) continue;\r\n            if (_x > this.worldHeight - 1 || _y > this.worldHeight - 1) continue;\r\n            if (this.startPanel.panel[_x][_y]) {\r\n                if (this.startPanel.panel[_x][_y] == \"yng\") {\r\n                    countYng++;\r\n                } else {\r\n                    conutYang++;\r\n                }\r\n                sum++;\r\n            }\r\n        }\r\n        return { countYng, conutYang, sum };\r\n    }\r\n\r\n    // количество живых клеток на поле\r\n    getLiveCount() {\r\n        let count = 0;\r\n        this.startPanel.panel.forEach((arr) => {\r\n            arr.forEach((item) => item && count++);\r\n        });\r\n        return count;\r\n    }\r\n}\r\n\r\nexport default IngYangGame;\r\n","// создать полотно, сетку и добавить события для чекбоксов\r\nclass SrartPanel {\r\n    constructor(colors, settings) {\r\n        const { canvas, grid } = createStartPanel(colors, settings);\r\n        this._settings = settings;\r\n        this._colors = colors;\r\n        this.canvas = canvas;\r\n        this.grid = grid;\r\n        this.panel;\r\n        this.setDefaultMatrix();\r\n    }\r\n\r\n    // очистить полотно\r\n    clearCanvas() {\r\n        this.canvas.getContext(\"2d\").clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    // обнулить матрицу панели\r\n    setDefaultMatrix() {\r\n        this.panel = this.defaultMatrix();\r\n    }\r\n\r\n    // создать пустую матрицу поля\r\n    defaultMatrix() {\r\n        const { width, height, cellSize } = this._settings,\r\n            iMax = Math.floor(width / cellSize),\r\n            jMax = Math.floor(height / cellSize),\r\n            panel = [];\r\n\r\n        for (let i = 0; i < iMax; i++) panel[i] = new Array(jMax);\r\n        return panel;\r\n    }\r\n\r\n    putCoordinateToCanvas(x, y) {\r\n        const { cellSize, cellType } = this._settings,\r\n            ctx = this.canvas.getContext(\"2d\");\r\n        ctx.fillStyle = this._colors[`${cellType}`];\r\n        ctx.fillRect(x * cellSize, y* cellSize, cellSize, cellSize);\r\n    }\r\n\r\n    putCoordinate({ x, y }) {\r\n        const { cellSize, cellType } = this._settings,\r\n            ctx = this.canvas.getContext(\"2d\");\r\n        this.panel[x / cellSize][y / cellSize] = cellType == \"empty\" ? null : cellType;\r\n        ctx.fillStyle = this._colors[`${cellType}`];\r\n        ctx.fillRect(x, y, cellSize, cellSize);\r\n    }\r\n\r\n    setEventListeners() {\r\n        // Показать/убрать сетку\r\n        document.querySelector(\"#grid_checkbox\").addEventListener(\"input\", () => {\r\n            this.grid.classList.toggle(\"hidden\");\r\n        });\r\n        // Показать/убрать полото\r\n        document.querySelector(\"#canvas_checkbox\").addEventListener(\"input\", () => {\r\n            this.canvas.classList.toggle(\"hidden\");\r\n        });\r\n\r\n        document.querySelector(\"#clear_button\").addEventListener(\"click\", () => {\r\n            this.clearCanvas();\r\n            this.setDefaultMatrix();\r\n        });\r\n    }\r\n\r\n    set settings(value) {\r\n        this._settings = value;\r\n    }\r\n\r\n    get settings() {\r\n        return this._settings;\r\n    }\r\n}\r\n\r\nfunction createStartPanel(colors, settings) {\r\n    const { width, height, cellSize } = settings;\r\n    // сетка canvas\r\n    function createGrid() {\r\n        const cnv = document.createElement(\"canvas\");\r\n        cnv.id = \"grid_canvas\";\r\n        cnv.width = width;\r\n        cnv.height = height;\r\n        let ctx = cnv.getContext(\"2d\");\r\n        ctx.strokeStyle = colors.grid;\r\n        let w = cnv.width - 1;\r\n        let h = cnv.height - 1;\r\n        for (let x = 0; x < w; x += cellSize) ctx.strokeRect(x, 0, 0.1, h);\r\n        for (let y = 0; y < h; y += cellSize) ctx.strokeRect(0, y, w, 0.1);\r\n        return cnv;\r\n    }\r\n\r\n    // основное полотно\r\n    function createCanvas() {\r\n        const cnv = document.createElement(\"canvas\");\r\n        cnv.classList.add(\"background\");\r\n        cnv.classList.add(\"transparency\");\r\n        cnv.id = \"canvas\";\r\n        cnv.width = width;\r\n        cnv.height = height;\r\n        cnv.style.backgroundColor = colors.empty;\r\n        return cnv;\r\n    }\r\n\r\n    return {\r\n        canvas: createCanvas(),\r\n        grid: createGrid(),\r\n    };\r\n}\r\n\r\nexport default SrartPanel;\r\n","class EmptyPoints {\r\n    constructor(sizeX, sizeY) {\r\n        this.points = [];\r\n        for (let i = 0; i < sizeX; i++) {\r\n            for (let j = 0; j < sizeY; j++) {\r\n                this.points.push([i, j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // случайнное перемешиване массива - алгоритм Фишера-Йетса \r\n    shuffle(){\r\n        let arr = this.points;\r\n        let j, temp;\r\n        for(let i = arr.length - 1; i > 0; i--){\r\n            j = Math.floor(Math.random()*(i + 1));\r\n            temp = arr[j];\r\n            arr[j] = arr[i];\r\n            arr[i] = temp;\r\n        }\r\n        return this.points;\r\n    }\r\n}\r\n\r\nexport default EmptyPoints;\r\n","import EmptyPoints from \"./empty-points\";\r\n\r\nfunction pointsGeneration(startPanel, colors) {\r\n    const canvas = startPanel.canvas,\r\n        ctx = canvas.getContext(\"2d\");\r\n    let { width, height, cellSize } = startPanel.settings;\r\n\r\n    /* -----------------------Рандомная генерация-------------------------------------------------*/\r\n    function randomGeneration() {\r\n        const percentYin = document.querySelector(\"#yin_percent\"),\r\n            percentYang = document.querySelector(\"#yang_percent\"),\r\n            countAlive = document.querySelector(\"#count_alive\"),\r\n            generButton = document.querySelector(\"#generate_button\");\r\n\r\n        function changePercent(param1, param2) {\r\n            let value = +param2.value > 100 ? 100 : +param2.value < 0 ? 0 : +param2.value;\r\n            param2.value = value;\r\n            param1.value = 100 - value;\r\n        }\r\n\r\n        // input-ы в рандомной генерации\r\n        percentYang.addEventListener(\"input\", () => changePercent(percentYin, percentYang));\r\n        percentYin.addEventListener(\"input\", () => changePercent(percentYang, percentYin));\r\n        countAlive.addEventListener(\"input\", () => {\r\n            let maxValue = Math.floor((width - 1) / cellSize) * Math.floor((height - 1) / cellSize),\r\n                curValue = +countAlive.value;\r\n            countAlive.value = curValue < 0 ? 0 : curValue > maxValue ? maxValue : +countAlive.value;\r\n        });\r\n\r\n        // кнопка генерации точек на полотне\r\n        generButton.addEventListener(\"click\", () => {\r\n            if (!countAlive.value || !percentYin.value || !percentYang.value) {\r\n                console.log(\"null check failed!!!\");\r\n                return;\r\n            }\r\n\r\n            let countYng = Math.round((+countAlive.value * +percentYin.value) / 100),\r\n                countYang = +countAlive.value - countYng,\r\n                maxSizeX = Math.floor((width - 1) / cellSize) * cellSize,\r\n                maxSizeY = Math.floor((height - 1) / cellSize) * cellSize;\r\n\r\n            // Сгенерировать масив рандомно перемешанных точек на плоскости\r\n            const emptyPoints = new EmptyPoints(maxSizeX / cellSize, maxSizeY / cellSize).shuffle();\r\n\r\n            // очищаем полотно\r\n            startPanel.clearCanvas();\r\n            startPanel.setDefaultMatrix();\r\n\r\n            // ставим новые точки\r\n            let prevCellType = startPanel.settings.cellType;\r\n            startPanel.settings.cellType = \"yng\";\r\n            for (let i = 0; i < countYng; i++) {\r\n                let [x, y] = emptyPoints.pop().map((item) => item * cellSize);\r\n                startPanel.putCoordinate({ x, y });\r\n            }\r\n            startPanel.settings.cellType = \"yang\";\r\n            for (let i = 0; i < countYang; i++) {\r\n                let [x, y] = emptyPoints.pop().map((item) => item * cellSize);\r\n                startPanel.putCoordinate({ x, y });\r\n            }\r\n            startPanel.settings.cellType = prevCellType;\r\n        });\r\n    }\r\n\r\n    /* -----------------------Пользовательская генерация------------------------------------------*/\r\n    function customGeneration() {\r\n        const radio = document.querySelectorAll('[name=\"radio\"]');\r\n\r\n        radio.forEach((item) => {\r\n            item.addEventListener(\"change\", (event) => (startPanel.settings.cellType = event.target.value));\r\n        });\r\n\r\n        // Координаты canvas относительно Window\r\n        function windowToCanvas(canvas, x, y) {\r\n            let bbox = canvas.getBoundingClientRect();\r\n            x -= bbox.left * (canvas.width / bbox.width);\r\n            y -= bbox.top * (canvas.height / bbox.height);\r\n            return {\r\n                x: Math.floor(x / cellSize) * cellSize,\r\n                y: Math.floor(y / cellSize) * cellSize,\r\n            };\r\n        }\r\n\r\n        canvas.addEventListener(\"mousedown\", (e) => {\r\n            startPanel.putCoordinate(windowToCanvas(e.target, e.clientX, e.clientY));\r\n        });\r\n\r\n        const canvasCoordinates = document.querySelector(\".canvas_coordinates\");\r\n        canvas.addEventListener(\"mousemove\", (e) => {\r\n            let { x, y } = windowToCanvas(e.target, e.clientX, e.clientY);\r\n            canvasCoordinates.innerHTML = `X: ${x / cellSize}; Y: ${y / cellSize}`;\r\n        });\r\n    }\r\n    /* -------------------------------------------------------------------------------------------*/\r\n\r\n    randomGeneration();\r\n    customGeneration();\r\n}\r\nexport default pointsGeneration;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// import \"materialize-css\";\r\nimport pointsGeneration from \"./components/points-generation\";\r\nimport SrartPanel from \"./components/canvas\";\r\nimport IngYangGame from \"./components/calc-yin-yang-points\";\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n    const container = document.querySelector(\"#container\");\r\n    /* -------------------------------НАСТРОЙКИ---------------------------------------------------------------------- */\r\n    const cell = 1;\r\n    const settings = {\r\n        cellSize: cell,\r\n        width: Math.floor(750 / cell) * cell + 1,\r\n        height: Math.floor(750 / cell) * cell + 1,\r\n        cellType: \"empty\",\r\n    };\r\n\r\n    const colors = { empty: \"#D3D3D3\", yng: \"#008000\", yang: \"#FF0000\", grid: \"black\" };\r\n\r\n    /* -------------------------------ОТРИСОВКА_ПОЛОТНА-------------------------------------------------------------- */\r\n    const startPanel = new SrartPanel(colors, settings);\r\n\r\n    startPanel.setEventListeners();\r\n\r\n    pointsGeneration(startPanel);\r\n\r\n    container.appendChild(startPanel.canvas);\r\n    container.appendChild(startPanel.grid);\r\n\r\n    /* -------------------------------НАЧАЛО_ИГРЫ-------------------------------------------------------------------- */\r\n    const startButton = document.querySelector(\"#start_button\"),\r\n        stepCount = document.querySelector(\".step_count\");\r\n    let isStarted = false,\r\n        curStep,\r\n        interval;\r\n\r\n    let game;\r\n\r\n    startButton.addEventListener(\"click\", () => {\r\n        isStarted = true;\r\n        curStep = 0;\r\n        game = new IngYangGame(startPanel);\r\n        interval = setInterval(() => start(), 1000);\r\n    });\r\n\r\n    function start() {\r\n        curStep++;\r\n        game.nextStep();\r\n        if (game.getLiveCount() == 0) {\r\n            clearInterval(interval);\r\n            isStarted = false;\r\n        }\r\n        stepCount.innerHTML = `Step: ${curStep}`;\r\n    }\r\n});\r\n"],"sourceRoot":""}